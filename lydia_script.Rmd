---
title: "lydia part of pres"
author: "Lydia Myers"
date: "5/16/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(factoextra)
library(dplyr)
library(ggplot2)
```

## phylopca

Alright, so now lets talk about what we did with the package we created. Gabi and I are both primatologists, and we're often interested in looking at the differences between different primates. PCA is a really helpful tool for analyses in our work, as we often have datasets with a whole lot of variables that would be difficult to analyze using non-PCA methods. The ideal type of analysis for our work is something that can deal with high dimensions of data, as well as easily look at differences between primates based on different levels of taxonomy, as it's always helpful to know if variation is only at the species level, or if it's also at the genus, or family, or even superfamily level. 

So, we created some functions that do just that - PCAs specific to different taxonomic levels. We created two PCA functions, one runs a PCA on the sample at the family level, and one runs a PCA at the superfamily level. We then created two plotting functions that pair with the PCA functions, and show the output of the PCAs, grouping the values by either family or genus, depending on the taxonomic level of the PCA. 

For demonstration of these functions, we used the Kamilar and Cooper dataset that we've worked with a bit in class this semester. The original dataset contained 40 variables with values for 213 primates. We pared this down, as a lot of the variables weren't numeric and PCA only runs on numeric data, and ended up with 13 variables of the same number of primates. The original dataset included columns for family, genus and species of each primate, but we added on another superfamily column so we could analyze that as well. Let's take a look at the data:

```{r data}
d <- read_csv("data.csv", col_names = TRUE)
head(d)
```

Before we run a PCA, we need to get rid of the NA values in the dataset, as the PCA won't run if they're there

```{r nas}
d<-na.omit(d)
```

Now, lets look at the function we created to do a PCA on the data based on taxonomic family

```{r pca fam}
pca.family<-function(data, family.name){
  data<-na.omit(data)
  dfam<-filter(data, Family==family.name)
  pcafam<-prcomp(Filter(is.numeric, dfam), center=T, scale=T)
  return(summary(pcafam))
}
```

If you look at the function code, you can see that it automatically removes the NAs in the data, so you don't need to do that. You can see that it then filters the data to include only the family which you specify with family.name = "<the family name>", and then runs a PCA using prcomp() on this subsetted data, and returns the summary. Let's look at the function that does the same thing, but groups by superfamily instead.

```{r pca superfam}
pca.superfamily<-function(data, superfamily.name){
  data<-na.omit(data)
  dsup<-filter(data, Superfamily==superfamily.name)
  pcasup<-prcomp(Filter(is.numeric, dsup), center=T, scale=T)
  return(summary(pcasup))
}
```

As you can see, it's doing the same this as pca.family, but it's subsetting by whichever superfamily you specify. Okay, now lets test out these two functions

```{r testing pcas}
pca.family(d, "Cercopithecidae")

pca.superfamily(d, "Ceboidea")
```

As you can see, I wanted to look at variation within Cercopithecidae, wich is a family of old world monkeys like baboons and macaques, for the first one, and the superfamily Ceboidea for the second one, which includes all of the extant new world monkeys like capuchins and spider monkeys. This function returns the standard deviation, proportion of variance, as well as the cumulative porportion of variance of each principle component it calculated for each of these PCAs. Now, let's take a look at what these PCAs actually look like.

We also created two sister functions to the PCA functions that graph the analyses we just did. Let's take a look at the function code.

```{r graph functions}
graph.family<-function(data, family.name){
  data<-na.omit(data)
  dfam<-filter(data, Family==family.name)
  pcafam<-prcomp(Filter(is.numeric, dfam), center=T, scale=T)
  fviz_pca_ind(pcafam, geom.ind = "point", pointshape = 21,
  pointsize = 2, fill.ind = dfam$Genus, invisible = "quali", palette = "pal8",
  addEllipses = T, legend.title="Genus") + labs(title = "PCA", x = "PC1", y = "PC2")
}

graph.superfamily<-function(data, superfamily.name){
  data<-na.omit(data)
  dsup<-filter(data, Superfamily==superfamily.name)
  pcasup<-prcomp(Filter(is.numeric, dsup), center=T, scale=T)
  fviz_pca_ind(pcasup, geom.ind = "point", pointshape = 21,
  pointsize = 2, fill.ind = dsup$Family, invisible = "quali", palette = "pal8",
  addEllipses = T, legend.title="Family") + labs(title = "PCA", x = "PC1", y = "PC2")
}
```

As you can see, the function actually runs the same PCAs that we ran in those last two functions, but then takes it a step further and graphs the first two PCs, and throws an ellipse around each genus in the first graph and each family in the second one. Lets test out these functions.

```{r testing graphs}
graph.family(d, "Cercopithecidae")

graph.superfamily(d, "Ceboidea")
```

One thing to note here is that the function can't put an ellipse around datapoints if there are only two or fewer, as is the case for most of the genera in this first graph. As you can see here, the majority of the variation falls along PC1, which is to be expected, with less falling along PC2. The genus Papio has a lot of variation across PC1, in comparison to the other genera here, and it looks like the other genera have a lot more variation along PC2 than Papio does. 

In the second graph, we're only looking at three families, only two of which have enough datapoints to be able to draw ellipses. Again, the majority of the variation is within PC1, with PC2 coming in second. The family Cebidae seems to vary a lot more along PC1 than Atelidae or Pitheciidae does, and the second two families seem to vary a lot more along PC2 than Cebidae does.

One of the really nice things about this function is that it's customizible with ggplot functions. So, if I for example wanted to change the tile of the second graph, it's super easy by using a + sign and some ggplot code.

```{r customizing graph}

graph.superfamily(d, "Ceboidea") + labs(title="PCA in Ceboidea")
```

The function provides a base graph that does what we need it to do, but it's fully customizable so I could make it look however I want without having to change the function itself. 

Our goal here was to create custom PCA functions that would allow for quick and easy PCA at different taxonomic levels, as well as a way to easily create aesthetically pleasing visualizations of those PCAs, and I think we reached that goal. So, does anyone have any questions?